<p class="ql-align-justify">Collection</p><p class="ql-align-justify">1.List</p><p class="ql-align-justify">1.1 ArrayList</p><p class="ql-align-justify">顾名思义是使用数组结构进行存储</p><p class="ql-align-justify">默认长度为10</p><p class="ql-align-justify">查找O(1)</p><p class="ql-align-justify">每次扩容1.5倍</p><p class="ql-align-justify">1.2LinkedList</p><p class="ql-align-justify">双向链表</p><p class="ql-align-justify">无需扩容</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">2.Map</p><p class="ql-align-justify">2.1Hashmap</p><p class="ql-align-justify">数组+链表</p><p class="ql-align-justify">数组大小必须为2的幂次方倍，因为取哈希下标时size-1按位与操作</p><attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-30a3f1c3-3882-4e33-91d7-9a7881a52d85" class="ql-align-justify"></attachment><p class="ql-align-justify">每个数组元素是链表，每个链表长度到一定以后变成红黑树</p><p class="ql-align-justify"><span style="background-color: rgb(255, 235, 204);">红黑树</span>：</p><p class="ql-align-justify">2.2LinkedHashMap</p><p class="ql-align-justify">给数组上增加了一个链表</p><p class="ql-align-justify">2.3TreeMap</p><p class="ql-align-justify">底层红黑树</p><p class="ql-align-justify">2.4HashTable</p><p class="ql-align-justify">线程安全的HashMap，会将整个存储结构锁住，其他线程无法操作</p><p class="ql-align-justify">2.5ConCurrentHashMap</p><p class="ql-align-justify">只锁当前桶</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">3.Set</p><p class="ql-align-justify">HashSet LinkedHashSet TreeSet 就是map把Value设置为Null</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">Thread</p><p class="ql-align-justify">1.线程的创建：</p><p class="ql-align-justify">继承Thread类</p><p class="ql-align-justify">实现Runnable接口</p><p class="ql-align-justify">线程池</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><span style="background-color: rgb(250, 204, 204);">线程池有哪几个有什么特点</span></p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><span style="background-color: rgb(250, 204, 204);">创建线程池的方法，重要的参数</span></p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">2.锁、同步问题：</p><p class="ql-align-justify">synchronized</p><p class="ql-align-justify">Lock接口，尝试拿锁，拿不到放弃</p><p class="ql-align-justify">最经典实现是Intrentent Lock, 可重入</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">读写锁</p><p class="ql-align-justify">只有读和读不互斥</p><p class="ql-align-justify">java如何避免锁饥饿、是不是默认避免了锁饥饿</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">3.ThreadLocal</p><p class="ql-align-justify">Thread对象中threadlocalmap属性的key，value为弱引用</p><p class="ql-align-justify">什么是弱引用</p><p class="ql-align-justify">弱引用</p><p class="ql-align-justify">什么场景会内存泄漏</p><p class="ql-align-justify">threadlocalmap 的底层：数组，每个元素就是值</p><p class="ql-align-justify">4.原子性</p><p class="ql-align-justify">用Atom的类保证原子性</p><p class="ql-align-justify">可见性</p><p class="ql-align-justify">volatile</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">JVM GC</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">类加载过程哪几步</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">双亲委派模型</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">类加载过程理解+打破双亲委派的方式</p><p><br></p>