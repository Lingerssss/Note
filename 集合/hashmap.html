<p>概括的说，<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">HashMap</code>&nbsp;是一个<strong>关联数组、哈希表</strong>，它是<strong>线程不安全</strong>的，允许<strong>key为null</strong>,<strong>value为null</strong>。遍历时<strong>无序</strong>。</p><p>其底层数据结构是<strong>数组</strong>称之为<strong>哈希桶</strong>，每个<strong>桶里面放的是链表</strong>，链表中的<strong>每个节点</strong>，就是哈希表中的<strong>每个元素</strong>。</p><p>在JDK8中，当链表长度达到8，会转化成红黑树，以提升它的查询、插入效率，它实现了<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">Map&lt;K,V&gt;, Cloneable, Serializable</code>接口。</p><p>因其底层哈希桶的数据结构是数组，所以也会涉及到<strong>扩容</strong>的问题。</p><p>当<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">HashMap</code>的容量达到<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">threshold</code>域值时，就会触发扩容。扩容前后，哈希桶的<strong>长度一定会是2的次方</strong>。</p><p>这样在根据key的hash值寻找对应的哈希桶时，可以<strong>用位运算替代取余操作</strong>，<strong>更加高效</strong>。</p><p>而key的hash值，并不仅仅只是key对象的<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">hashCode()</code>方法的返回值，还会经过<strong>扰动函数</strong>的扰动，以使hash值更加均衡。</p><p>因为<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">hashCode()</code>是<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">int</code>类型，取值范围是40多亿，只要哈希函数映射的比较均匀松散，碰撞几率是很小的。</p><p>但就算原本的<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">hashCode()</code>取得很好，每个key的<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">hashCode()</code>不同，但是由于<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">HashMap</code>的哈希桶的长度远比hash取值范围小，默认是16，所以当对hash值以桶的长度取余，以找到存放该key的桶的下标时，由于取余是通过与操作完成的，会忽略hash值的高位。因此只有<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">hashCode()</code>的低位参加运算，发生不同的hash值，但是得到的index相同的情况的几率会大大增加，这种情况称之为<strong>hash碰撞。</strong>&nbsp;即，碰撞率会增大。</p><p><strong>扰动函数</strong>就是为了解决hash碰撞的。它会综合hash值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少hash碰撞的概率。（在JDK8之前，扰动函数会扰动四次，JDK8简化了这个操作）</p><p>扩容操作时，会new一个新的<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">Node</code>数组作为哈希桶，然后将原哈希表中的所有数据(<code style="background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);">Node</code>节点)移动到新的哈希桶中，相当于对原哈希表中所有的数据重新做了一个put操作。所以性能消耗很大，<strong>可想而知，在哈希表的容量越大时，性能消耗越明显。</strong></p><p>扩容时，如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。</p><p>因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位= low位+原哈希桶容量</p><p>如果追加节点后，链表数量》=8，则转化为红黑树</p><p>由迭代器的实现可以看出，遍历HashMap时，顺序是按照哈希桶从低到高，链表从前往后，依次遍历的。属于<strong>无序</strong>集合</p><attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-788a6b10-2997-4704-952a-8e86d0b7fd5c"></attachment><p><br></p>